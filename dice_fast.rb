# Задача программы - нахождения вероятности того, что при броске n m - гранных
# кубиков, сумма получиться k.

class Dice
  class << self

    # Находим количество возможных выпадений n кубиков с m гранями таких,
    # что сумма выпавших чисел равняется k - m.
    # Представим эту задачу следующим образом:
    # Пусть имеется k камней. Их нужно разбить на n множеств, причем
    # мощность каждого множества не должна превосходить m + 1.
    # Пример для одного разложения:
    # n = 5; m = 3; k = 9
    #
    # |*||**|*
    #
    # Получае подмножества слудующих мнощностей:
    # 1, 2, 1, 3, 2
    def sum_equal_to(n, m, k)

      # Подготовка и проверка параметров
      return 0 if k < n or k > n*m
      m -= 1
      k -= n

      # Массив, в котором будут храниться текущее значение положения границы.
      # Для решения задачи достаточно n - 1 границы.
      x = Array.new(n - 1){ 0 }

      # Массив границ изменения положения соответствующей границы.
      # В хеше будет 2 ключа: текущее значение ( :cur ) и максимальное ( :max )
      bounds = Array.new(n - 1) { 0 }

      # Вычисляем пределы изменения первой границы.
      # На минимальное значение накладываются следующие ограничение:
      #  1) в первом множестве не должно лежать не меньше 0 элементов.
      #  2) количество оставшихся камней должно быть не больше, чем (n - 1) * m
      #     (условие того, что будет мозможно хотя бы один вариант выпадения)
      # На максимальное значение накладываются следующие ограничение:
      # в первом множестве не должно лежать больше m элементов.
      #      bounds[0][:cur] = k - ((n -1 ) * m) > 0 ? k - ((n -1 ) * m) : 0
      x[0] = k - ((n -1 ) * m) > 0 ? k - ((n -1 ) * m) : 0
      #      bounds[0]  = bounds[0][:cur] + m < k ? bounds[0][:cur] + m : k
      bounds[0] = x[0] + m < k ? x[0] + m : k
      x[0] -= 1 # необходимо в цикле

      i = 0; # текущая обрабатываемая граница

      # Массив промежуточных сумм.
      sums = Array.new(n - 1){ 0 }

      # Запомненные результаты.
      # Вычислив один раз значение для конкретной границы и ее положения
      # будем использовать это значение снова.
      # Первый индекс - номер границы, второй - ее положение.
      remembered = Array.new(n - 1){ Array.new }

      # Цикл, в котором последовательно будут двигаться границы
      until x[0].nil? do

        x[i] += 1 # сдвагаем границу вправо

        # Может это уже вычисленно?
        if i > 0 and ( !remembered[i][ x[i - 1] ].nil? )
          sums[i] = remembered[i][ x[i - 1] ]
          i -= 1
        elsif i < n - 2 # Проверяем, последняя ли это граница
          # не последняя

          # Если мы еще не рассматривали i + 1 -ую границу,
          # то sums[i + 1] равно 0.
          # Если рассматривали - просто используем результат.
          sums[i] += sums[i + 1]
          sums[i + 1] = 0

          if x[i] > bounds[i]
            # Если получили недопустимую границу, то возвращаемся.
            # Перед возращением запоминаем результут
            remembered[i][ x[i - 1] ] = sums[i] unless i == 0
            # "Убираем" за собой,
            bounds[i] = nil
            x[i] = nil
            # возращаемся.
            i -= 1 unless i == 0
          else
            # Если такая граница является допустимой и не последняя,
            # то вычисляем пределы для следующей.
            x[i + 1] = k - (n - i - 2) * m > x[i] ? k - (n - i - 2) * m : x[i]
            bounds[i + 1] = x[i] + m > k ? k : x[i] + m
            x[i + 1] -= 1
            # Переходим к следующей границе
            sums[i + 1] = 0
            i += 1
          end
        else
          # Если это последняя граница, то просто вычисляем возможные варианты
          #          puts "#{x.inspect}\n#{bounds[i] }\n"

          sums[i] = bounds[i] - x[i] + 1
          bounds[i] = nil
          x[i] = nil
          i -= 1
        end

      end
      sums[0]
    end

    # Расчет вероятности
    def probability(n, m, k)
      return 0 if m == 0
      sum_equal_to(n, m, k).to_f / ( m**n )
    end

  end
end

k, n, m = *ARGV.map{|e| e.to_i}

puts Dice.probability(n, m, k)

